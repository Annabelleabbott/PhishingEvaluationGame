from flask import request, jsonify, render_template
from flask_pymongo import PyMongo
import os
from pathlib import Path
from bson.json_util import dumps
from flask_cors import CORS, cross_origin
import random


def init_routes(app, mongo):
    @app.route('/')
    @cross_origin()
    def index():
        collections = mongo.db.list_collection_names()
        return render_template('index.html', collections=collections)


    @app.route('/add_email')
    @cross_origin()
    def add_email():
        email = {
            "subject": "Test Email",
            "content": "This is a test email.",
            "type": "Legitimate",
            "source": "Human"
        }
        mongo.db.emails.insert_one(email)
        return "Email added!"
    
    @app.route('/add_all_emails')
    @cross_origin()
    def add_all_emails():
        directory_path = Path(__file__).parent.parent / 'data' / 'emails'/ 'llm' / 'linkedin'

        email_id_counter = 1

        for file in directory_path.iterdir():
            if file.is_file():
                with open(file, 'r') as f:
                    content = f.read()

                email = {
                    "email_id": f"email_{email_id_counter}",
                    "content": content,
                    "type": "Fake",
                    "source": "LLM"
                }

                
                mongo.db.emails.insert_one(email)

            
                email_id_counter += 1

        return f"{email_id_counter - 1} emails added!"
    
    # @app.route('/api/next-email')
    # @cross_origin()
    # def get_next_email():
    #     # email = mongo.db.emails.find_one({}, {'_id': 0})  

    #     # if email:
    #     #     return dumps(email)
    #     # else:
    #     #     return jsonify({"error": "No emails available"}), 404
    #     email = random.choice(list(mongo.db.emails.find()))
    #     if email:
    #         return jsonify(email)
    #         #return email['email']
    #     else:
    #         return jsonify({"error": "No emails available"}), 404


    @app.route('/api/next-email')
    @cross_origin()
    def get_next_email():
        try:
            #emails = list(mongo.db.emails.find())
            #need this 
            emails = list(mongo.db.emails.find({}, {'_id': 0}))
            if emails:
                email = random.choice(emails)
                return jsonify(email)  # Make sure to exclude the '_id' field if not serializable
            else:
                return jsonify({"error": "No emails available"}), 404
        except Exception as e:
            # Log the exception to help diagnose the issue
            print(f"Error fetching email: {e}")
            return jsonify({"error": "Internal server error"}), 500


    @app.route('/get_emails')
    @cross_origin()
    def get_emails():
        emails = mongo.db.emails.find()
        return str(list(emails))

    @app.route('/submit_user_data')
    @cross_origin()
    def submit_user_data():
        """
        Category 1 condition: user response if they believe email was generated by LLM or Human (determined by buttons selected)
        Category 2 condition: user response if they believe email is phishing email or legitamate email
        """
        # Here you can access the data sent from the frontend using request.form or request.json
        data = request.json
        email_id = data.get('emailId')
        user_response = data.get('response')

        if not email_id or not user_response:
            return jsonify({"error": "Missing emailId or response"}), 400

        # Save the response to the database
        # This is a placeholder; you'll need to implement the actual save logic
        # For example: mongo.db.responses.insert_one({'email_id': email_id, 'response': user_response})

        return jsonify({"message": "Response saved successfully"})
